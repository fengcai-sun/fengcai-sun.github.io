<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on 静心明志</title>
    <link>https://fengcai-sun.github.io/categories/algorithm/</link>
    <description>Recent content in algorithm on 静心明志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 09 May 2019 17:45:45 +0800</lastBuildDate>
    
	<atom:link href="https://fengcai-sun.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>198.打家劫舍</title>
      <link>https://fengcai-sun.github.io/2019/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</link>
      <pubDate>Thu, 09 May 2019 17:45:45 +0800</pubDate>
      
      <guid>https://fengcai-sun.github.io/2019/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</guid>
      <description>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
示例 1:
输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。  示例 2:
输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。  代码：
public static int rob(int[] nums) { int length = nums.</description>
    </item>
    
    <item>
      <title>11.盛最多水的容器</title>
      <link>https://fengcai-sun.github.io/2019/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 09 May 2019 16:57:00 +0800</pubDate>
      
      <guid>https://fengcai-sun.github.io/2019/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
      <description>给定 n 个非负整数 *a*1，*a*2，&amp;hellip;，*a*n，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
说明：你不能倾斜容器，且 n 的值至少为 2。
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
示例:
输入: [1,8,6,2,5,4,8,3,7] 输出: 49  代码：
class Solution { public int maxArea(int[] height) { int maxeara = 0; int i=0, j=height.length-1; while(i&amp;lt;j){ maxeara = Math.max(maxeara, Math.min(height[i], height[j])*(j-i)); if(height[i]&amp;gt;height[j]) j--; else i++; } return maxeara; } }  </description>
    </item>
    
  </channel>
</rss>